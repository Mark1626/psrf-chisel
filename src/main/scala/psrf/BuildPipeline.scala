package psrf

import java.io.File
import java.io.PrintWriter
import java.nio.file.Files
import java.text.SimpleDateFormat
import java.util.Calendar
import scala.sys.process._
import chisel3._
import chisel3.stage.ChiselGeneratorAnnotation
import firrtl.AnnotationSeq
import firrtl.options.TargetDirAnnotation
import firrtl.stage.OutputFileAnnotation

object BuildPipeline {
  lazy val runsDirectory             = new File("runs")
  lazy val srcDirectory              = new File("src")
  lazy val pythonSrcDirectory        = new File(srcDirectory, "main/python")
  lazy val cppSrcDirectory           = new File(srcDirectory, "main/cpp")
  lazy val swStageSrcFile            = new File(pythonSrcDirectory, "main.py")
  lazy val pythonVenvDirectory       = new File("env")
  lazy val pythonVenvActivationFile  = new File(pythonVenvDirectory, "/bin/activate")
  lazy val pythonPipRequirementsFile = new File("requirements.txt")

  val hwStageConfigFileName = "hwStageConfig.json"

  def timeStamp: String = {
    val format = new SimpleDateFormat("yyyyMMddHHmmss")
    val now    = Calendar.getInstance.getTime
    format.format(now)
  }

  def createRunDirectories(): (File, File) = {
    runsDirectory.mkdirs()
    val runDir   = Files.createTempDirectory(runsDirectory.toPath(), timeStamp).toFile
    val buildDir = new File(runDir, "build")
    buildDir.mkdirs()
    (buildDir, runDir)
  }

  def runProcess(cmd: ProcessBuilder, logger: ProcessLogger, errorMsg: String = "An exception occured"): Unit =
    if (cmd.!(logger) == 1) sys.error(errorMsg)

  def generateVerilog(dut: () => RawModule, targetDir: String): AnnotationSeq = (new chisel3.stage.ChiselStage).execute(
    Array("-X", "verilog"),
    Seq(
      TargetDirAnnotation(targetDir),
      ChiselGeneratorAnnotation(dut)
    )
  )

  def apply(pipelineConfigFilePath: String, verbose: Boolean): Unit = {

    // Create directories and files for storing build products
    val (buildDir, runDir)   = createRunDirectories()
    val buildDirAbsolutePath = buildDir.getAbsolutePath()
    val runDirAbsolutePath   = runDir.getAbsolutePath()

    val stdoutFile         = new File(s"${runDirAbsolutePath}/stdout.txt")
    val logFile            = new File(s"${runDirAbsolutePath}/stderr.log")
    val vcdFile            = new File(s"${runDirAbsolutePath}/waveform.vcd")
    val pipelineConfigFile = new File(pipelineConfigFilePath)
    val hwStageConfigFile  = new File(buildDir, hwStageConfigFileName)

    // Process logger for the build pipeline
    val stdout = new PrintWriter(stdoutFile)
    val stderr = new PrintWriter(logFile)
    val logger = ProcessLogger(s => { println(s); stdout.write(s + "\n") }, s => { println(s); stderr.write(s + "\n") })

    def printIfVerbose(s: String): Unit = if (verbose) { println(s); stdout.write(s + "\n") }

    // Software stage
    // Commands
    val pythonVenvCreateCmd = Seq("python", "-m", "venv", pythonVenvDirectory.getAbsolutePath())
    //val pythonVenvActivateCmd = Seq("source", pythonVenvActivationFile.getAbsolutePath())
    val pythonVenvActivateCmd = Seq("/bin/cat", pythonVenvActivationFile.getAbsolutePath()) #| Seq("/bin/sh")
    val pythonPipInstallRequirementsCmd =
      pythonVenvActivateCmd #&& Seq("pip", "install", "-r", pythonPipRequirementsFile.getAbsolutePath())
    val swStageCmd = pythonVenvActivateCmd #&& Seq(
      "python",
      pythonSrcDirectory.toPath.toAbsolutePath.toString + File.separator + "main.py",
      "--config",
      pipelineConfigFile.toPath.toAbsolutePath.toString,
      "--out",
      hwStageConfigFile.toPath.toAbsolutePath.toString,
      (if (verbose) "--verbose" else "")
    )

    // Create a python virtual environment
    printIfVerbose("Creating a python virtual environment...")
    runProcess(pythonVenvCreateCmd, logger, "An error occured while creating the python virtual environment")

    // Install required python packages
    printIfVerbose("Installing required python packages...")
    runProcess(
      pythonPipInstallRequirementsCmd,
      logger,
      "An error occured while installing the required python packages"
    )

    // Run software stage python script
    printIfVerbose("Running software training stage...")
    runProcess(swStageCmd, logger, "An error occured during the software training stage")

    // Hardware stage
    // Read hardware stage configuration generated by software stage
    printIfVerbose(s"Reading hardware stage configuration file: ${hwStageConfigFile.getAbsolutePath()}...")
    val hwStageConfigSource = scala.io.Source.fromFile(hwStageConfigFile)
    val hwStageConfigLines =
      try hwStageConfigSource.mkString
      finally hwStageConfigSource.close()
    val hwStageConfigParseResult = HWStageConfig(hwStageConfigLines) match {
      case Right(hwStageConfig) => {
        printIfVerbose("Read hardware stage configuration file successfully!")
        hwStageConfig
      }
      case Left(error) => sys.error(error.getMessage())
    }

    // Get CDE configuration for chisel circuit generation
    val chiselCDEConfig = hwStageConfigParseResult.getCDEConfig()

    // Instantiate chisel module based on build type
    val dut = hwStageConfigParseResult.buildType match {
      case "test" => {
        printIfVerbose("Test build type chosen")
        () => new RandomForestClassifierTestHarness()(chiselCDEConfig)
      }
      case "prod" => sys.error("Production build type is not currently supported")
      case u      => sys.error("Unknown build type: " + u)
    }

    // Compiling Chisel to Verilog
    printIfVerbose("Compiling Chisel to Verilog...")
    val annos     = generateVerilog(dut, buildDirAbsolutePath)
    val buildName = annos.collectFirst { case OutputFileAnnotation(f) => f }.get
    val outputVerilogFileName =
      s"${buildDirAbsolutePath}/${buildName}.v"
    printIfVerbose(s"Generated Verilog file: ${outputVerilogFileName}")

    // Build stage
    // TODO Make tracing an option from the configuration file
    val trace = true
    val verilatorCmakeCmd = Seq(
      "cmake",
      "-S",
      s"${cppSrcDirectory.getAbsolutePath()}",
      "-B",
      buildDirAbsolutePath,
      s"-DBUILD_SIMULATOR=${buildName}",
      s"-DVERILOG_SRC=${outputVerilogFileName}",
      s"-DVERILATOR_TRACE=${if (trace) "ON" else "OFF"}"
    )

    val verilatorBuildCmd = Seq(
      "cmake",
      "--build",
      buildDirAbsolutePath
    )

    val verilatorRunCmd =
      Seq(buildDirAbsolutePath + File.separator + buildName, { if (trace) vcdFile.getAbsolutePath else "" })

    hwStageConfigParseResult.buildTarget match {
      case "sim" => {
        printIfVerbose("Simulation build target chosen")
        printIfVerbose("Building the Verilator simulator...")
        runProcess(
          verilatorCmakeCmd #&& verilatorBuildCmd,
          logger,
          "An error occured while building the verilator simulator"
        )
        printIfVerbose("Running the Verilator simulator...")
        runProcess(verilatorRunCmd, logger, "An error occured while running the verilator simulator")
        printIfVerbose("Build done!!!")
      }
      case "synth" => {
        printIfVerbose("Synthesis build target chosen")
        printIfVerbose("Build done!!!")
      }
    }

    stdout.close()
    stderr.close()
  }
}
